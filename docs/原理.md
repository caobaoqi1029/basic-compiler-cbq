这个项目是一个基于 Java 的简单计算器，它使用 Pratt parsing 技术来解析和计算数学表达式。

> Pratt parsing 是一种自顶向下的解析技术，通过将表达式分解成嵌套的操作符和操作数来工作。每个操作符都有相应的优先级，而 Pratt 解析器则利用这些优先级来决定表达式的结构。例如，乘法操作符的优先级高于加法，因此 Pratt 解析器会先解析乘法表达式，然后再处理加法。

该项目的结构被组织为多个包和类，每个类都有其特定的职责。下面是项目的主要组成部分和它们各自的作用：

1. `ast` (Abstract Syntax Tree) 包：
   - `Expression.java`：这个接口定义了所有表达式的共同行为。
   - `InfixExpression.java`：表示中缀表达式的类，比如加法或乘法。
   - `IntegerExpression.java`：用于表示整数值的表达式。
   - `Node.java`：AST 的基本节点接口。
   - `PrefixExpression.java`：表示前缀表达式的类，比如一元负号。

2. `evaluator` 包：
   - `Evaluator.java`：负责计算 AST 并返回结果的类。

3. `lexer`： 负责将输入的数学表达式字符串转换成 token 序列的词法分析器。
   - `Lexer.java`：负责将输入的数学表达式字符串转换成 token 序列的词法分析器。

4. `object` 包：
   - `MInt.java`：表示计算器中的整数对象。
   - `MObj.java`：定义了计算器中所有对象的基本行为。

5. `parser` 包：语法分析器
   - `InfixParseFn.java`：用于解析中缀表达式的接口。
   - `Parser.java`：解析 token 序列并构建 AST 的解析器。
   - `Precedence.java`：定义了不同操作符的优先级。
   - `PrefixParseFn.java`：用于解析前缀表达式的接口。

6. `token` 包：
   - `Token.java`：表示词法单元的类。
   - `TokenType.java`：定义了不同类型的 token。

7. `Main.java`：程序的入口点，负责初始化和启动计算器。

8. 测试文件和测试扩展：
   - `LexerTest.java`：测试词法分析器的功能。
   - `TestLoggerExtension.java`：为测试提供额外的日志功能。

在这个计算器项目中，词法分析器（`Lexer`）首先将输入的数学表达式字符串分解为 token 序列。然后，解析器（`Parser`）使用这些 token，根据定义的优先级和解析函数，构建一个 AST。最后，计算器使用求值器（`Evaluator`）对这个 AST 进行计算，得出最终结果。

每个操作符都有对应的解析函数，分别用于处理中缀（`InfixParseFn`）和前缀（`PrefixParseFn`）表达式。这些解析函数负责识别和构造 AST 中的相应节点。

整个计算器的工作流程大致如下：
1. 输入数学表达式。
2. 词法分析器将输入转换为 token 序列。
3. 解析器读取 token 序列，并根据操作符的优先级构建 AST。
4. 求值器遍历 AST，并计算出结果。



---

编译器的基本流程通常包括几个主要阶段：词法分析（Lexical Analysis）、语法分析（Syntax Analysis）、语义分析（Semantic Analysis）、中间代码生成（Intermediate Code Generation）、优化（Optimization）和目标代码生成（Code Generation）。然而，由于你的项目是一个简易计算器，它可能不需要所有的这些步骤。下面是一个简化的编译器（或解释器）的执行流程，适用于你的计算器项目：

1. **词法分析（Lexing）**：
   - 输入：用户输入的数学表达式字符串。
   - 处理：`Lexer` 类将字符串转换为 token 序列。每个 token 是表达式的一个原子部分，如数字、运算符或括号。
   - 输出：一系列 token。

2. **语法分析（Parsing）**：
   - 输入：词法分析阶段输出的 token 序列。
   - 处理：`Parser` 类读取 tokens 并根据语法规则构建抽象语法树（AST）。Pratt parsing 技术在这里发挥作用，使用不同的解析函数来处理不同的 token 类型（如前缀和中缀）。
   - 输出：一个 AST，它表示了输入表达式的结构。

3. **语义分析（Semantic Analysis）**：
   - 输入：语法分析阶段构建的 AST。
   - 处理：这个阶段通常涉及检查 AST 是否符合语义规则，如变量是否已定义，类型是否匹配等。在简单计算器中，这个阶段可能会进行一些基本的检查，例如确保数值操作数的有效性或者操作符使用是否正确。
   - 输出：经过验证的 AST。

4. **求值（Evaluation）**：
   - 输入：经过语义分析的 AST。
   - 处理：`Evaluator` 类遍历 AST，并执行计算。这通常涉及递归地计算每个节点的值，根据操作符节点的类型执行相应的数学运算。
   - 输出：最终的计算结果。

对于你的计算器项目，执行流程可能看起来像这样：

```java
public static void main(String[] args) {
    String input = "3 + 5 * (10 - 4)"; // 假设这是用户输入的表达式字符串
        Lexer lexer = new Lexer(input); // 创建词法分析器实例

        // 创建一个新的Lexer实例来生成一个新的token序列
        Lexer lexer2 = new Lexer(input);
        List<Token> tokens2 = lexer2.getTokenList();
        tokens2.forEach(System.out::println);

        Parser parser = new Parser(lexer); // 创建语法分析器实例
        Expression expression = parser.parseMain(); // 解析 tokens 并构建 AST

        // 如果需要的话，在这里进行语义分析
        Evaluator evaluator = new Evaluator(); // 创建求值器实例
        MObj result = evaluator.eval(expression); // 对 AST 进行求值

        System.out.println(result); // 输出计算结果
}
```

在这个流程中，每个阶段都是连续的，输出一个阶段是下一个阶段的输入。如果在任何阶段发生错误，比如语法错误或类型错误，程序应该能够捕获这些错误并向用户提供有用的反馈。

---

要实现一个基本的编译器（在这个情况下，是一个简单的计算器），你需要遵循以下基本步骤，这些步骤对应于编译器的主要阶段：词法分析、语法分析、语义分析（在某些情况下）、生成中间表示、优化（可选）和代码生成。对于你的计算器项目，主要关注的是前几个阶段。

### 1. 词法分析（Lexical Analysis）

- **目标**：将源代码（输入的数学表达式）转换为一系列的 token。Token 是构成表达式的最小单位，例如数字、操作符、括号等。
- **实现**：通过 `Lexer` 类实现。`Lexer` 需要读取输入字符串，并识别出所有的 token，如整数、加号、乘号等。每个 token 都有一个类型和可能的值。

### 2. 语法分析（Syntax Analysis）

- **目标**：将 token 序列转换成抽象语法树（AST）。AST 是表达式的树形表示，其中每个节点都代表了表达式的一部分，如一个运算或操作数。
- **实现**：通过 `Parser` 类实现。`Parser` 会使用一个或多个解析函数（如 `InfixParseFn` 和 `PrefixParseFn`）来处理不同种类的 token，并根据它们的优先级和组合构建 AST。

### 3. 语义分析（Semantic Analysis）

- **目标**：在这个阶段，编译器会检查 AST 的语义正确性，比如类型检查、变量使用前是否已声明等。对于简单的计算器，这个阶段可能会很简单或甚至可以省略，因为计算器的语义通常直接由解析过程和表达式的结构确定。
- **实现**：在你的项目中，这个阶段可能通过 `Evaluator` 类在执行时隐含地进行，例如在求值过程中检查除以零的错误等。

### 4. 生成中间表示（Intermediate Representation, IR）

- **目标**：生成一种更容易进行优化和转换成目标代码的中间表示。对于简单的计算器，AST 本身就可以视为一种 IR。
- **实现**：在你的项目中，AST 本身作为 IR。

### 5. 优化（Optimization）

- **目标**：改进 IR 以提高执行效率。对于一个简单的计算器，可能不需要复杂的优化。
- **实现**：可选步骤，对于基础计算器可能不适用。

### 6. 代码生成（Code Generation）

- **目标**：将 IR 转换为可执行代码。在你的计算器项目中，这个阶段通常涉及到遍历 AST 并计算出结果。
- **实现**：通过 `Evaluator` 类实现。`Evaluator` 遍历 AST，对每个节点进行计算，并返回最终的计算结果。

### 执行流程示例：

1. 用户输入一个数学表达式。
2. `Lexer` 分析表达式并生成 token 序列。
3. `Parser` 读取 token 序列，并构建对应的 AST。
4. `Evaluator` 遍历 AST 并计算出结果。

这个流程概括了从输入表达式到获取计算结果的整个过程。每个步骤都是编译器设计的关键部分，即使在这样一个简单的计算器项目中也是如此。希望这能帮助你更好地理解程序的执行流程。如果有任何问题或需要进一步的解